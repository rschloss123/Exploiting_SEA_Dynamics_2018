% Produce a static, nominal trajectory that is at equilibrium with the
% springs. This trajectory is used for iteration 1 of the linear
% optimization. 
function [x_input, x_baseline,u_baseline]= ...
    get_nominal_trajectory(x_nominal, A_1, B1_1, B1_2, B1_3, B1_4,...
    utilize_compliance, s1v, s2v,m_L1,m_L2, A,B_12,B_34,...
    theta_init1, theta_unshift_init2, N)

    x1_est = x_nominal(1,1)+x_nominal(1,3); % link 1 displacement
    dx1_est = x_nominal(1,2)+x_nominal(1,4); % link 1 velocity 
    x2_est = x_nominal(1,5)+x_nominal(1,7); % link 1 displacement
    dx2_est = x_nominal(1,6)+x_nominal(1,8); % link 1 velocity          
    % Note that theta2_unshift is with respect to link 1. The angle of link 2
    % with respect to the horizontal axis is theta1+theta2

    theta1 = get_theta1(x1_est);
    theta2_unshift = get_theta_2(x2_est);
    theta2_shift= theta2_unshift+pi;

    [r1, r2] = getr(theta1,theta2_unshift);
    
    theta_dot1 = dx1_est/r1;
    theta_dot2 = dx2_est/r2;

    % Lagrangian Dynamic
    [H11, H22, H12, H21, h, G1, G2] = get_dynamic_components(theta1,theta2_shift);

    % Compute F' 
    [F_x_components, F_u_components, F_b_components, ~] = ...
        get_F_components(H11, H22, H12, H21, h, G1, G2,...
        theta1, theta2_unshift, r1, r2, theta_dot1, theta_dot2,...
        A_1, B1_1, B1_2, B1_3, B1_4, s1v, s2v,m_L1,m_L2);

    % Discretized time-varying update equation
    [A_lin1(:,:),B_lin1(:,:),bias_lin1(:,:)] = linearize_matrices(A,B_12,B_34,F_x_components,...
        F_u_components,F_b_components);

    % solve for nominal x0 and nominal u0
    S = [(eye(8)-A_lin1), -B_lin1; 1 0 1 0 0 0 0 0 0 0; 0 0 0 0 1 0 1 0 0 0];
    z_init = [bias_lin1; get_x1(theta_init1); get_x2(theta_unshift_init2)];
    x_init = S\z_init;
    x0 = x_init(1:8,1)';
    u0 = x_init(9:10,1)';

    % configure x_baseline or z_baseline from nominal trajectory
    if utilize_compliance == 1 
        x_input(:,:)= ones(N,1)*x0;
        x_baseline = x_input;
    else
       z1 = x0(1)+x0(3);
       z1_dot = x0(2)+x0(4);
       z2 = x0(5)+x0(7);
       z2_dot = x0(6)+x0(8); 
       z0 = [z1 z1_dot z2 z2_dot];
       x_input(:,:)= ones(N,1)*z0;
       x_baseline = x_input;
    end
    
    u_baseline = ones(N-1,1)*u0; 

end 