% Main File for simulation and analysis of the Draco leg 

% Notes
% theta1 is an absolute angle
% theta2_unshift is shifted by pi in order to be with respect to link 1
% The absolute angle of link 2 is theta1+theta2_shift

clear all;
close all;
tic
global L_1 L_c1 L_c2 time_step k_S m_1 m_2
% There are different options to run this program:
% 1) Input = 1: Solve the optimization problem
% 1A) utilize_compliance = 1: Solve the problem while considering the actuator
% subsystems' dynamics
%   i. Euler_method = 0: Use z_double_dot that is calculated using equation
%   (12) in paper 
%   ii. Euler_method = 1: Use Euler's method to linearize problem in the convex
%   optimization sub-problem
% 1B) utilize_compliance = 0: Solve the optimization problem without considering the
% actuator subsystem's dynamics (rigid case)
% 2) Input = 0: Analyze the zero input behavior of the system


%% Parameters for Comparisons and Analysis

% 1 equals true, utilize compliance
% 0 equals false, no actuator dynamics considered
utilize_compliance = 1; 

% 1 = true, use Euler method (utilize_compliance should = 1 and input
% should = 1)
% 0 = false
Euler_method = 0;

% Set input to 0 to analyze zero input behavior.
% For input = 0, utilize_compliance should = 1 and Euler_method should = 0.
% Set input to 1 to run convex optimization program.
input = 1;

% 1 = true, analyze convergence rate. This accomplished by evaluating error when 
% comparing to the trajectory produced at the 15th iteration. 
% In this configuration, set:
% utilize_compliance = 1
% Euler_method = 0
% input = 1
analyze_convergence = 0;
if analyze_convergence == 1
    filename = 'nominal_compliant_trajectory.mat';
    load(filename)    
end 

% Mass of M_L+M_P. This can be an array or a single value.
%mass = [100:100:1500]; 
mass =  580; %20; %0;%580;%0; %580;  %1110; %

% Scales for spring constant. This can be an array or a single value.
%spring_scale = [.5/3 .75/3 1/3, 2/3, 1 4/3, 5/3, 6/3, 7/3, 8/3, 9/3];
spring_scale = 2.5/3;

% Penalization in cost function. This can be an array or a single value.
%penalty_array = [1e-9 1e-8 1e-7 1e-6 1e-5 1e-4 5e-3 7e-3 5e-2 6e-2 7e-2 8e-2 9e-2]; %1e-2 1e-1 1
penalty_array = [1e-5];
F_pen = 1e-8;

% save data
% z trajectory (rigid behavior)
save_z_data = 0;
% upward velocity (rigid or compliant)
save_y_velocity_data = 0; 
% save x trajectory (compliant behavior)
save_x_data = 0;

% Use rigid trajectory as nominal trajectory for compliant case when
% use_rigid_nominal = 1.
use_rigid_nominal = 0;
if use_rigid_nominal == 1
    % load reference data
    filename = 'nominal_rigid_trajectory.mat';
    load(filename)
    filename = 'nominal_u.mat'; 
    load(filename,'u_baseline') 
end 

runtime = 0; 
%% Eigenvalues
% For analysis of eigenvalues for differing M_L+M_p
period_a_lin =zeros(1,length(mass));
period_a_1= zeros(1,length(mass));
optimal = zeros(1,length(mass)); 
frequency_a_lin = zeros(1,length(mass));
frequency_a_1 = zeros(1,length(mass));
period_continuous = zeros(1,length(mass));
frequency_continuous = zeros(1,length(mass));

% Used to analyze behavior for varying spring constants.
if length(spring_scale) > 1
    k_values = zeros(1,length(spring_scale));
end 

%% Begin Evaluation
% Different tests can be run to evaluate performance based on varying
% m_L+m_P, spring constant, and penalty on the input. Only one test should
% be run at a time.

if length(mass)>1
    % test differemt m_L+m_P
    end_test = length(mass);
elseif length(spring_scale) > 1
    % test different spring constants
    end_test = length(spring_scale);
elseif length(penalty_array) > 1
    % test different penalties on the inputs u1, u2
    end_test = length(penalty_array);
else
    end_test = 1; % no test is being run
end 

for r = 1: end_test
    clf
    if length(mass) > 1 
        disp(mass(r))
    end
    % configure iterations
    if length(penalty_array) > 1
        iters = 40;
    else
        iters = 40;
    end 
    % configure N and step_size
    if (utilize_compliance == 1 && input == 1 && Euler_method == 0 )|| utilize_compliance == 0
        N = 85;%100;%50;  
        time_step = .0095;%.0095;
    elseif utilize_compliance == 1 && input == 1 && Euler_method == 1
        N = 807;
        time_step = .001;
    elseif utilize_compliance == 1 && input == 0
        N = 5987;%65;
        time_step = .0001;%.0095;%.0001;% .0095;%
    end 

    if length(mass)>1
        m_L1 = mass(r);
        m_L2 = mass(r);
    else
        m_L1 = mass(1);
        m_L2 = mass(1);
    end
    if length(spring_scale) > 1
        scale = spring_scale(r);
    else
        scale = spring_scale(1); 
    end
    k_S = 300000*scale; % N/m 
    disp(k_S)
    
    if length(penalty_array) > 1
        penalty = penalty_array(r);
        disp(penalty)
    else 
        penalty = penalty_array(1);
    end 
    if length(spring_scale) > 1
        k_values(r) = k_S;
    end 
    %% Model Parameters
    [limit1_lower, limit1_upper, limit2_lower, limit2_upper,...
    trust, foot_length1, foot_length2, mu] = get_parameters;

    %% Continuous Time System

    [A_1,B_1] = get_continuous_matrices(m_L1,m_L2,1);
    if utilize_compliance == 0
        [A_1_NC,B_1_NC] = get_continuous_matrices(m_L1,m_L2,utilize_compliance);
    else
        B_1_NC = 0;
    end
    
    % Eigenvalues of A_1
    if utilize_compliance == 1
        eigenvalues = eig( A_1 );
        max_eig_a1 = max(abs(eigenvalues));
    else
        eigenvalues = eig( A_1_NC );
        max_eig_a1 = max(abs(eigenvalues));        
    end

    
    %% Discrete time system
    [A,B] = get_discrete_matrices(A_1,B_1,1);
    if utilize_compliance == 0
        % configure discrete model for rigid system
        [A_NC,B_NC] = get_discrete_matrices(A_1_NC,B_1_NC,0);
    else
        A_NC = 0; 
        B_NC = 0; 
    end 

    %% Matrices for Linearization
    [s1v, s2v,B1_1, B1_2, B1_3, B1_4, B_12, B_34,B1_12, B1_34,...
    B1_1_NC, B1_2_NC, B1_3_NC, B1_4_NC, s1v_NC, s2v_NC, B_12_NC,...
    B_34_NC] = ...
    linearization_components(Euler_method, utilize_compliance, ...
    B_1, B, B_1_NC, B_NC);
   
    %% Simulation Parameters

    % optimal value array, in order to evaluate convergence with tolerance
    % \epsilon
    opt_val_check_convergence = zeros(iters,1);

    if input == 1
        % starting possition (equals ending position)
        angle_adjust =  0;
        h = .67;%.7999;
        d = -.008; %\\-.0342;
        [theta_init1, theta_unshift_init2] = get_starting_position(h,d);
        theta_init1 = theta_init1+angle_adjust;
        theta_unshift_init2 = theta_unshift_init2 - 2*angle_adjust;
        theta_final1 = theta_init1;
        theta_unshift_final2 = theta_unshift_init2;
        [~, ~, ~,~, com_x, com_y] = link_animation_components(theta_init1, theta_unshift_init2+pi);
    else
        % test no-input behavior from nearly-vertical position
        theta_init1 = pi/2;
        theta_unshift_init2 = pi-.1;  
        theta_final1 = theta_init1;
        theta_unshift_final2 = theta_unshift_init2;
    end

    % moment arms
    r1 = zeros(N,1);
    r2 = zeros(N,1);

    % Linearization matrices
    if utilize_compliance == 1
        A_lin = zeros(8,8,N);
        B_lin = zeros(8,2,N);
        bias_lin = zeros(8,1,N);
    else 
        A_lin = zeros(4,4,N);
        B_lin = zeros(4,2,N);       
        bias_lin = zeros(4,1,N);
    end
    
    if Euler_method == 1
        % Matrices to use Euler Method
        A_prime = zeros(8,8,N);
        B_prime = zeros(8,2,N);
        bias_prime = zeros(8,1,N);
    end 

    % generalized joint positions
    theta1 = zeros(N,1);
    theta2_unshift = zeros(N,1);
    theta2_shift = zeros(N,1);
    x_nominal(:,:)= ones(N,1)*[0,0,get_x1(theta_init1),0,0,0,get_x2(theta_unshift_init2),0];
    theta_dot1 = zeros(N,1);
    theta_dot2 = zeros(N,1);

    if analyze_convergence == 1
        % Used to evaluate error behavior as iterations increases
        error = zeros(1,iters);
    end 

    % estimate of acceleration
    ddx1_est = zeros(N-1,1);
    ddx2_est= zeros(N-1,1);
    % Wrench Components
    wrench_nominal = zeros(3,N); 
    Constraint_Jacobian = zeros(3,2,N);
    
  
    %% Getting nominal trajectory      
    % x(+,:) = A*x(-,:) + B(:,1)*u(1) + B(:,2)*u(2) +
    %          + B(:,3)*u(3) + B(:,4)*u(4)          ;

    % Nominal trajectory at equilibrium with springs 
    if input == 1
        if use_rigid_nominal == 0
            [x_input, x_baseline,u_baseline] = ...
                get_nominal_trajectory(x_nominal, A_1, B1_1, B1_2, B1_3, B1_4,...
                utilize_compliance, s1v, s2v,m_L1,m_L2, A,B_12,B_34,...
                theta_init1, theta_unshift_init2,N);

        % use the optimal trajectory for the rigid system as the nominal
        % trajectory for the compliant system
        elseif use_rigid_nominal == 1
            x_input(:,3) = zcvx(:,1);
            x_input(:,4) = zcvx(:,2);
            x_input(:,7) = zcvx(:,3);
            x_input(:,8) = zcvx(:,4); 
            x_baseline = x_input;

        end


        % Parameters to configure final upward velocity at N
        x1_final = get_x1(theta_final1);
        x2_final = get_x2(theta_unshift_final2);   
        theta_2_unshift_final = get_theta_2(x2_final);
        % Change in joint angle with respect to actuator length for ankle
        [Tdot1_final, ~] = get_ankle_jacobian(x1_final);
        % Change in joint angle with respect to actuator length for knee
        [Tdot2_final, ~] = solve_knee_jacobians2(theta_2_unshift_final);

        if utilize_compliance == 0
            % These variables were used to generate the nominal trajectory for
            % the rigid case
            clearvars s1v s2v B1_1 B1_2 B1_3 B1_4 B_12 B_34 B1_12 B1_34
        end 
    elseif input == 0
        x_input = x_nominal;
    end


    %% Iterative Simulation  
    % Maximum eigenvalue of linearized system 
    max_eig = 0; 
    if input == 0
        % no input for zero-input evaluation
        u = zeros(N-1,2);
    end 
    
    
    figure(1)
    hold on
    for i = 1:iters
        for j = 1:N
            % x(+,:) = A*x(-,:) + B(:,1)*u(1) + B(:,2)*u(2) +
            %          + B(:,3)*u(3) + B(:,4)*u(4)          ;
            if utilize_compliance == 1 
                % states for compliant system
                x1_est = x_input(j,1)+x_input(j,3); % link 1 displacement
                dx1_est = x_input(j,2)+x_input(j,4); % link 1 velocity 
                x2_est = x_input(j,5)+x_input(j,7); % link 1 displacement
                dx2_est = x_input(j,6)+x_input(j,8); % link 1 velocity          
            else
                % states for rigid system
                x1_est = x_input(j,1); % link 1 displacement
                dx1_est = x_input(j,2); % link 1 velocity 
                x2_est = x_input(j,3); % link 2 displacement
                dx2_est = x_input(j,4); % link 2 velocity   
            end
            theta1(j) = get_theta1(x1_est);
            theta2_unshift(j) = get_theta_2(x2_est);
            % formulation for lagrangian dynamics
            theta2_shift(j)= theta2_unshift(j)+pi;

            % moment arm
            [r1(j), r2(j)] = getr(theta1(j),theta2_unshift(j));
            % angular velocity
            theta_dot1(j) = dx1_est/r1(j);
            theta_dot2(j) = dx2_est/r2(j);
    
            % Lagrangian dynamics 
            [H11, H22, H12, H21, h, G1, G2] = get_dynamic_components(theta1(j),theta2_shift(j));
            

            if utilize_compliance == 1
                % Compute F' for compliant case
                [F_x_components, F_u_components, F_b_components, ~] = ...
                    get_F_components(H11, H22, H12, H21, h, G1, G2,...
                    theta1(j), theta2_unshift(j), r1(j), r2(j), theta_dot1(j), theta_dot2(j),...
                    A_1, B1_1, B1_2, B1_3, B1_4, s1v, s2v,m_L1,m_L2);
            elseif utilize_compliance == 0
                % no actuator dynamics considered (rigid system)
                [F_x_components, F_u_components, F_b_components, ~] = ...
                    get_F_components(H11, H22, H12, H21, h, G1, G2,...
                    theta1(j), theta2_unshift(j), r1(j), r2(j), theta_dot1(j), theta_dot2(j),...
                    A_1_NC, B1_1_NC, B1_2_NC, B1_3_NC, B1_4_NC, s1v_NC, s2v_NC,m_L1,m_L2);
            end 
            if utilize_compliance == 1 && Euler_method == 0
                % Create linear approximation of system, using discrete A
                % and B
                [A_lin(:,:,j),B_lin(:,:,j),bias_lin(:,:,j)] = ...
                    linearize_matrices(A,B_12,B_34,...
                    F_x_components,F_u_components,F_b_components);
            elseif utilize_compliance == 0
                [A_lin(:,:,j),B_lin(:,:,j),bias_lin(:,:,j)] = ...
                    linearize_matrices(A_NC,B_12_NC,B_34_NC,...
                    F_x_components,F_u_components,F_b_components);                           
            elseif utilize_compliance == 1 && Euler_method == 1
                % Utilize Euler method

                % Notice that the change here compared to above is the use of
                % the A_1 and B_1 matrix as opposed to the A and B discrete
                % matrices 
                [A_prime(:,:,j),B_prime(:,:,j),bias_prime(:,:,j)] = ...
                    linearize_matrices(A_1,B1_12,B1_34,F_x_components,F_u_components,F_b_components);        
                A_lin(:,:,j) = eye(8,8)+time_step*A_prime(:,:,j) ;
                B_lin(:,:,j) = time_step*B_prime(:,:,j);
                bias_lin(:,:,j) = time_step*bias_prime(:,:,j);  
            end

            if j < N
                % Used to compute reaction forces at foot
                z_step = x_input(j:j+1,:);             
                [ddx1_est(j),ddx2_est(j)] = approximate_accelerations(z_step, utilize_compliance);
                [wrench_nominal(:,j), Constraint_Jacobian(:,:,j)] = ContraintComponents(z_step,x1_est,x2_est,...
                    dx1_est,dx2_est,ddx1_est(j),ddx2_est(j),bias_lin(:,:,j),utilize_compliance);
           end 
        end 

        % Obtain maximum eigenvalue of linearized system 
        if input == 1 %utilize_compliance == 1
            for eig_check = 1:N
                eigenvalues = eig( A_lin(:,:,eig_check) );
                eigenvalues = log(eigenvalues); % take the log because A_lin is discrete 
                test = max(abs(eigenvalues));
                if test > max_eig
                    max_eig = test;
                end 
            end 
        end   
        
        if input == 1
        % do convex optimization
         % Maximimize upward velocity at hip at final time 

            cvx_begin 
            cvx_solver gurobi 

            if utilize_compliance == 1 % compliant
                variable x_out(N,8)
                %variable absdev(N,8)
            else % rigid 
                variable x_out(N,4)
                %variable absdev(N,4)
            end
            variable c_constraint(N,4)
            variable u(N-1,2) 
            variable absu(N-1,2) 
            %variable absx1(N,1)
            %variable absx2(N,1)
            
          %  function below verifies no motion
           %minimize 0.00001*sum(absx1)+0.00001*sum(absx2)
           %minimize 0.00001*sum( abs(x_out(:,1)+x_out(:,3)-x_baseline(:,1)-x_baseline(:,3) ))+0.00001*sum( abs(x_out(:,5)+x_out(:,7)-x_baseline(:,5)-x_baseline(:,7) ))
          
           if utilize_compliance == 1 
                % Compliant case
                    minimize -(m_1*L_c1*cos(theta_final1)*Tdot1_final*(x_out(N,2)+x_out(N,4))+...
                         m_2*L_1*cos(theta_final1)*Tdot1_final*(x_out(N,2)+x_out(N,4))+...
                         m_2*L_c2*cos(theta_final1+theta_unshift_final2+pi)*...
                         (Tdot1_final*(x_out(N,2)+x_out(N,4))+Tdot2_final*(x_out(N,6)+x_out(N,8))))/...
                         (m_1+m_2)+penalty*sum(absu(:,1))+penalty*sum(absu(:,2))+...
                         F_pen*sum(c_constraint(:,1))+F_pen*sum(c_constraint(:,2))+...
                         F_pen*sum(c_constraint(:,3))+F_pen*sum(c_constraint(:,4))

           elseif utilize_compliance == 0
                    % rigid case
                    minimize -(m_1*L_c1*cos(theta_final1)*Tdot1_final*x_out(N,2)+...
                         m_2*L_1*cos(theta_final1)*Tdot1_final*x_out(N,2)+...
                         m_2*L_c2*cos(theta_final1+theta_unshift_final2+pi)*...
                         (Tdot1_final*x_out(N,2)+Tdot2_final*x_out(N,4)))/...
                         (m_1+m_2)+penalty*sum(absu(:,1))+penalty*sum(absu(:,2))+...
                         F_pen*sum(c_constraint(:,1))+F_pen*sum(c_constraint(:,2))+...
                         F_pen*sum(c_constraint(:,3))+F_pen*sum(c_constraint(:,4))

           end  

           % Constraints
            subject to
            
            % Verify no motion
%             absx1 >= (x_out(:,1)+x_out(:,3)-x_baseline(:,1)-x_baseline(:,3) )
%             -absx1 <= (x_out(:,1)+x_out(:,3)-x_baseline(:,1)-x_baseline(:,3) ) 
%             absx2 >= (x_out(:,5)+x_out(:,7)-x_baseline(:,5)-x_baseline(:,7) )
%             -absx2 <= (x_out(:,5)+x_out(:,7)-x_baseline(:,5)-x_baseline(:,7) )


            if utilize_compliance == 0 % rigid behavior
                % No actuator dynamics
                
                    % Joint Limit Constraints
                    limit1_lower<= x_out(:,1) <= limit1_upper
                    limit2_lower <= x_out(:,3) <= limit2_upper
                    get_x1(0+.5) <= x_out(:,1) <= get_x1(pi-.5);
                    get_x2(pi-.5) <= x_out(:,3) <= get_x2(.01+.5)
 

                    % Starting Point Constraint
                    x_out(1,:) == x_baseline(1,:);

                    % End Dispacement Constraints
                    x_out(N,1)==get_x1(theta_final1);
                    x_out(N,3)== get_x2(theta_unshift_final2);

                    % No x-velocity at last time step
                    (-m_1*L_c1*sin(theta_final1)*Tdot1_final*(x_out(N,2))...
                         -m_2*L_1*sin(theta_final1)*Tdot1_final*(x_out(N,2))...
                         -m_2*L_c2*sin(theta_final1+theta_unshift_final2+pi)*...
                         (Tdot1_final*(x_out(N,2))+Tdot2_final*(x_out(N,4))))/...
                         (m_1+m_2) == 0                       
                   
                        % Baseline Deviation Constraints
                        -trust*ones(N,1) <= (x_out(:,1)-x_baseline(:,1)) <= trust*ones(N,1); 
                        -trust*ones(N,1) <= (x_out(:,3)-x_baseline(:,3)) <= trust*ones(N,1);
     
                        %Ballscrew Limit
                        -.3 <= x_out(:,2) <= .3; % m/s
                        -.3 <= x_out(:,4) <= .3; % m/s
                        


            else
                % Utilize compliance

                % Spring Deflection (m) Constraint
                -0.01*(1/scale)  <= x_out(:,1) <= 0.01*(1/scale) ; % spring deflection limit (meters) 
                -0.01*(1/scale)  <= x_out(:,5) <= 0.01*(1/scale); % spring deflection limit (meters)

                % Joint Limit Constraints
                limit1_lower<= x_out(:,1)+x_out(:,3) <= limit1_upper
                limit2_lower <= x_out(:,5)+x_out(:,7) <= limit2_upper

                get_x1(0+.5) <= x_out(:,1)+x_out(:,3) <= get_x1(pi-.5)
                get_x2(pi-.5) <= x_out(:,5)+x_out(:,7) <= get_x2(.01+.5)         
 
                % Starting Point Constraint
                x_out(1,:) == x_baseline(1,:);

                % End Dispacement Constraints
                x_out(N,1)+x_out(N,3)==get_x1(theta_final1);
                x_out(N,5)+x_out(N,7)== get_x2(theta_unshift_final2);

                % Baseline Deviation Constraints
                -trust*ones(N,1) <= (x_out(:,1)+x_out(:,3)-x_baseline(:,1)-x_baseline(:,3)) <= trust*ones(N,1); 
                -trust*ones(N,1) <= (x_out(:,5)+x_out(:,7)-x_baseline(:,5)-x_baseline(:,7)) <= trust*ones(N,1);


                % No x-velocity at last time step
                (-m_1*L_c1*sin(theta_final1)*Tdot1_final*(x_out(N,2)+x_out(N,4))...
                     -m_2*L_1*sin(theta_final1)*Tdot1_final*(x_out(N,2)+x_out(N,4))...
                     -m_2*L_c2*sin(theta_final1+theta_unshift_final2+pi)*...
                     (Tdot1_final*(x_out(N,2)+x_out(N,4))+Tdot2_final*(x_out(N,6)+x_out(N,8))))/...
                     (m_1+m_2) == 0                
                                
                % Ballscrew Limit
                -.3 <= (x_out(:,4)) <= .3; % m/s
                -.3 <= (x_out(:,8)) <= .3; % m/s
                

            end          
                % Constraints Applicable for Rigid and Compliant 
                % Reaction Force Constraints
                % Linearization Constraint
                for j = 1: N-1
                    x_out(j+1, :) == x_out(j,:)*A_lin(:,:,j)'+...
                        u(j,:)*B_lin(:,:,j)'+...
                        bias_lin(:,:,j)';
                end 
                
                % Wrench constraints
                for n = 1:N-1      
                    c_constraint(n,:)*[mu 1 -foot_length1; -mu 1 -foot_length1; mu 1 foot_length2; -mu 1 foot_length2] == ...
                    wrench_equation(wrench_nominal(:,n),Constraint_Jacobian(:,:,n),...
                    A_lin(:,:,n),B_lin(:,:,n),u(n,:),x_out(n,:),...
                    utilize_compliance);       

                    c_constraint(n,1)>=0;
                    c_constraint(n,2)>=0;
                    c_constraint(n,3)>=0;
                    c_constraint(n,4)>=0;                                    
                end    
                
                c_constraint(N,1)==0;
                c_constraint(N,2)==0;
                c_constraint(N,3)==0;
                c_constraint(N,4)==0;  

                % Current Constraint, applicable for both situations
                -15.0 <= u(:,:) <= 15.0; % A
                
                % used so that absu = |u-a_baseline|
                 absu(:,:) >= u(:,:)-u_baseline(:,:)
                -absu(:,:) <= u(:,:)-u_baseline(:,:)               
                
            cvx_end

                        
            % update baseline trajectory             
            if isequal(cvx_status, 'Solved') 
                x_baseline = x_out; 
                x_last_success_input = x_input;
                x_last_success_output = x_out;
                x_input =  x_last_success_output;
                A_prev1 = A_lin;
                B_prev1 = B_lin;
                bias_prev1 = bias_lin;
                wrench_nominal_prev = wrench_nominal; 
                Constraint_Jacobian_prev = Constraint_Jacobian;  
            % If infeasible:
            else
                x_input = .5*(x_last_success_input+x_input);
            end


            
        % If we are evaluating zero-input behavior, optimization is not
        % performed 
        elseif input == 0
            [row, col] = size(x_input);
            x_out = zeros(row,col);
            x_out(1,:) = x_input(1,:);
            for j = 1: N-1
                x_out(j+1, :) = x_out(j,:)*A_lin(:,:,j)'+...
                    u(j,:)*B_lin(:,:,j)'+...
                    bias_lin(:,:,j)';
            end
            
            x_last_success_input = x_input;
            x_last_success_output = x_out;
            x_input =  x_last_success_output;
            solve = 1;

        end 
        var = num2str(i);

        if utilize_compliance == 1
            figure(1)
            plot(real(x_input(:,1))+real(x_input(:,3)), real(x_input(:,5))+real(x_input(:,7)),'DisplayName',var,'Linewidth',1)   
        else
            figure(1)
            %plot3([0:N-1]'*time_step,x_out(:,1),x_out(:,3));
            plot(x_out(:,1),x_out(:,3),'DisplayName',var,'Linewidth',1); 
        end
        if input == 1           
            if isequal(cvx_status, 'Solved') 
                solve = 1; 
                opt_val_check_convergence(i) = cvx_optval;
            else 
                solve = 0;
            end 
        end 
        
        %Stop iterations if convergence occurs within specified tolerance

        if i > 1
            %if abs(opt_val_check_convergence(i) - opt_val_check_convergence(i-1)) < .001 && solve == 1
            if norm(x_last_success_input-x_last_success_output) < .001 && solve == 1
                % run time
                timerVal2 = toc;
                runtime = runtime+timerVal2;
                break


            end
        end 
 
        
        % Error analysis, relative error considering 2-norm
        if analyze_convergence == 1
            error(i) = norm(x_compare_convergence-x_out)/norm(x_compare_convergence);
        end

    end

    %% Plots 

    % Used to track eigenvalues
    if input == 1 %utilize_compliance == 1
        % Evauluate eigenvalues
        maximum = max_eig;
        period_a_lin(r) =1/((max_eig/time_step)/(2*pi));
        period_a_1(r)=1/((max_eig_a1)/(2*pi)); % recall that A1 is a continuous matrix,
                                               % and hence time_step is not
                                               % inclued 
        frequency_a_lin(r) = max_eig/time_step;
        frequency_a_1(r) = max_eig_a1;
    end
    if input == 1 && length(penalty_array) == 1
        optimal(r) = cvx_optval; % the cvx_optval includes any penalizations on u   
    elseif input == 1 && length(penalty_array) > 1
        % upward y velocity 
        z_1_dot_final = x_out(N,2)+x_out(N,4);
        z_2_dot_final = x_out(N,6)+x_out(N,8);
        optimal(r) = get_y_velocity(theta_final1,theta_unshift_final2,...
            z_1_dot_final,z_2_dot_final,Tdot1_final,Tdot2_final);
    end 

    % Store our trajectories 
    if utilize_compliance == 1
        xcvx = x_out; 
        % Period and natural frequency for the continuous system. Used to
        % compare against A_1 and A_lin
        [period_continuous(r), frequency_continuous(r)] = Nonlinear_Dynamics(x_out, N,m_L1,m_L2,...
            A_1, B_1, B1_1, B1_2, B1_3, B1_4, s1v, s2v, utilize_compliance);     
    elseif utilize_compliance == 0 && input == 1
        [period_continuous(r), frequency_continuous(r)] = Nonlinear_Dynamics(x_out, N,m_L1,m_L2,...
            A_1_NC, B_1_NC, B1_1_NC, B1_2_NC, B1_3_NC, B1_4_NC, s1v_NC, s2v_NC, utilize_compliance);         
        zcvx = x_out;
        if save_z_data == 1
            filename = 'nominal_rigid_trajectory.mat'; 
            save(filename,'zcvx')
            filename = 'rigid_constraints.mat'; 
            save(filename,'c_constraint')   
            filename = 'nominal_u.mat'; 
            save(filename,'u_baseline') 
        end

    end 

    % Save x data. Typically the data is used for analyzing convergence 
    if save_x_data == 1
        x_compare_convergence = x_out;
        filename = 'nominal_compliant_trajectory.mat';
        save(filename,'x_compare_convergence') 
        filename = 'compliant_constraints.mat'; 
        save(filename,'c_constraint')   
        save('animation_parameters', 'N','foot_length1','foot_length2','mu')
    end

    % Compute the upward center of mass velocities in order to compare 
    % rigid to compliant behavior
    if save_y_velocity_data == 1
        Tdot1_array = zeros(N,1);
        Tdot2_array = zeros(N,1); 
        % save files in order to compare behavior using
        % yVelocityComparison.m
        if utilize_compliance == 1
            z_1_evaluate_y_velocity = x_out(:,1)+x_out(:,3);
            z_dot_1_evaluate_y_velocity = x_out(:,2)+x_out(:,4); 
            z_dot_2_evaluate_y_velocity = x_out(:,6)+x_out(:,8);
            filename = 'yVelocityCompliant.mat';
        elseif utilize_compliance == 0
            z_1_evaluate_y_velocity = x_out(:,1);
            z_dot_1_evaluate_y_velocity = x_out(:,2);
            z_dot_2_evaluate_y_velocity = x_out(:,4);
            filename = 'yVelocityRigid.mat';
        end 
        for w = 1:N
            Tdot1_array(w) = get_ankle_jacobian(z_1_evaluate_y_velocity(w));
            Tdot2_array(w) = solve_knee_jacobians2(theta2_unshift(w)) ;       
        end 
        if utilize_compliance == 1
            y_velocity_compliant = get_y_velocity(theta1(:,:),theta2_unshift(:,:),...
                z_dot_1_evaluate_y_velocity(:,:),z_dot_2_evaluate_y_velocity(:,:),...
                Tdot1_array(:,:),Tdot2_array(:,:));
            save(filename,'y_velocity_compliant')
        elseif utilize_compliance == 0
             y_velocity_rigid = get_y_velocity(theta1(:,:),theta2_unshift(:,:),...
                z_dot_1_evaluate_y_velocity(:,:),z_dot_2_evaluate_y_velocity(:,:),...
                Tdot1_array(:,:),Tdot2_array(:,:));
            save(filename,'y_velocity_rigid');     
        end 

    end 
    % Store our input trajectory
    ucvx = u;
end
legend('show')
if input == 1
    title('Trajectories for Jumping Behavior')

else
    title('Trajectories for Zero Input Behavior')
    axis([0.19,.27,.15,.24])
end 
xlabel('z_1 (m)')
ylabel('z_2 (m)')
set(gca,'Fontsize',18)
set(gca,'fontname','times')
grid on


% Plot eigenvalues for varying ficticious mass values 
if Euler_method == 0 && length(mass) > 1
    figure()
    plot(mass, frequency_continuous, 'DisplayName', 'Continuous System','Linewidth',1.5)
    hold on 
    plot(mass, frequency_a_1, 'DisplayName', 'A_1','Linewidth',1.5)
    plot(mass, frequency_a_lin,'k', 'DisplayName', 'A_{lin}','Linewidth',1.5)
    legend('show')
    xlabel('M_p (kg)')
    ylabel('Natural Frequency (Hz)')
    title('Maximum Eigenvalue for Varying M_p')
    set(gca,'Fontsize',18)
    set(gca,'fontname','times')
    grid on

    figure()
    plot(optimal,frequency_continuous)
    xlabel('frequency of continuous system')
    ylabel('optimal velocity (m/s)')
end 

% Plot error vs. number of iterations
if analyze_convergence == 1
    figure()
    semilogy(1:iters,error,'Linewidth',1.5)
    xlabel('Iteration')
    ylabel('Error')
    title('Rate of Convergence')
    set(gca,'Fontsize',18)
    set(gca,'fontname','times')
    grid on
end 


% Spring Stiffness Comparison
if utilize_compliance == 1 && Euler_method == 0 && length(spring_scale) > 1
    figure()
    plot(k_values, -optimal)
    xlabel('Spring Constant (N/m)')
    ylabel('optimal velocity (m/s)')    
end 

% Penalty comparison
if length(penalty_array) > 1
    figure()
    semilogx(penalty_array, optimal,'Linewidth',1.5)
    xlabel('Penalty on u_1 and u_2')
    ylabel('Optimal Velocity (m/s)') 
    title('Optimal Velocity Based on Input Penalization')
    set(gca,'Fontsize',18)
    set(gca,'fontname','times')
    grid on
end 

if utilize_compliance == 1
    % Plot dispacements and velocities over time 
    figure()
    plot([0:N-1]*time_step, real(x_out(:,1))+real(x_out(:,3)),'DisplayName','x1')
    hold on 
    plot([0:N-1]*time_step, real(x_out(:,2))+real(x_out(:,4)),'DisplayName','x1dot')
    plot([0:N-1]*time_step, real(x_out(:,5))+real(x_out(:,7)),'DisplayName','x2')
    plot([0:N-1]*time_step, real(x_out(:,6))+real(x_out(:,8)),'DisplayName','x2dot')
    legend('show')
    xlabel('time (s)')
    ylabel('trajectory (m)')
    hold off 
    
    % Plot Spring Deflection over time 
    figure()
    plot([0:N-1]*time_step,real(x_out(:,1)*1000),'Linewidth',1.5,'DisplayName','\delta_1')
    hold on
    plot([0:N-1]*time_step,real(x_out(:,5)*1000),'Linewidth',1.5,'DisplayName','\delta_2')
    legend('show')
    xlabel('Time (s)')
    ylabel('Spring Deflection (mm)')
    title('Spring Deflection Trajectories')
    set(gca,'Fontsize',18)
    set(gca,'fontname','times')
    grid on
    hold off
    %axis([0,.5,-10,11])
end 


% Plot u's 
figure()
plot([0:N-2]*time_step,ucvx(:,1),'Linewidth',1.5,'DisplayName','u_1')
hold on
plot([0:N-2]*time_step,ucvx(:,2),'Linewidth',1.5,'DisplayName','u_2')
legend('show')
% axis([0,.5,-16,16])
xlabel('Time (s)','Interpreter','latex')
ylabel('Input Current (A)')
title('Input Trajectories')
set(gca,'Fontsize',18)
set(gca,'fontname','times')
grid on
hold off 

%% Checks: Kinetic and Potential Energy, and Torque
if utilize_compliance == 1
    T = zeros(N-1,1);
    U = zeros(N-1,1);
    diss = zeros(N-1,1);
    Torque1 = zeros(N,1);
    Torque2 = zeros(N,1);
    for j = 1:N-1
        x1_est = x_out(j,1)+x_out(j,3); % link 1 displacement
        dx1_est = x_out(j,2)+x_out(j,4); % link 1 velocity 
        x2_est = x_out(j,5)+x_out(j,7); % link 1 displacement
        dx2_est = x_out(j,6)+x_out(j,8); % link 1 velocity       
        % kinetic energy and potential energy
        [T(j),U(j),diss(j),Torque1(j),Torque2(j)] = checks(x_out(j:j+1,:),x1_est,dx1_est,x2_est,dx2_est,ddx1_est(j),ddx2_est(j),utilize_compliance);
    end 

    % Total Mechanical Energy
    figure()
    plot([0:N-2]'*time_step,real(T),'DisplayName','Kinetic Energy','LineWidth', 2);
    hold on
    plot([0:N-2]'*time_step,real(U),'DisplayName','Potential Energy','LineWidth', 2);
    plot([0:N-2]'*time_step,real(T)+real(U)+real(diss),'DisplayName','Total Energy','LineWidth', 2);
    legend('show')
    xlabel('Time (s)')
    ylabel('Energy (J)')
    hold off

%     % Torques
%     figure()
%     plot([1:N]'*time_step, Torque1,'DisplayName','torque1')
%     hold on
%     title('torque 1 verification')
%     xlabel('time (s)')
%     ylabel('torque1')
%     legend('show')
%     hold off
% 
%     figure()
%     plot([1:N]'*time_step, Torque2,'DisplayName','torque2')
%     hold on
%     title('torque 2 verification')
%     xlabel('time (s)')
%     ylabel('torque2')
%     legend('show')
%     hold off
end

% Animate resulting behavior

if utilize_compliance == 1 && input == 1
  animate_results(utilize_compliance, xcvx, N, foot_length1, foot_length2, input, c_constraint, mu,0,ucvx)
elseif utilize_compliance == 1 && input == 0
  animate_results(utilize_compliance, xcvx, N, foot_length1, foot_length2, input, 0, mu,0,ucvx)
elseif utilize_compliance == 0
  animate_results(utilize_compliance, zcvx, N, foot_length1, foot_length2, input, c_constraint, mu,0,ucvx)  
end
